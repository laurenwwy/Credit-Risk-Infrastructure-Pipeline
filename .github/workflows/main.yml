# identity and Trigger
# What it does: This is simply the name of the workflow.
# Where it shows up: When you look at the "Actions" tab on GitHub, you will see this name. 
# It helps you distinguish this job from others (e.g., you might have another job for "Daily Backups"). 

name: Credit Risk CI and CD

# Trigger: Run this whenever you push code to GitHub
# The Trigger: This tells GitHub when to wake up the robot.
# Meaning: "Every time I push code to this repository, start this robot immediately." (You can also set it to run on a schedule, like every night at 2 AM).
on: 
  push:
    branches: [main] #Only deploy when code is pushed to the 'main' branch
    

# jobs: A workflow is made of one or more "jobs." Here, we just have one named build.
# runs-on: ubuntu-latest: This tells GitHub what kind of virtual computer to use.
# Ubuntu is a version of Linux. Most banks and tech companies run their real servers on Linux because it is fast and secure.
# latest means "use the newest version available."
jobs:
# --- PHASE 1: CI (Continuous Integration) ---
  test-and-validate:
    runs-on: ubuntu-latest
    
    # The steps are the individual tasks the robot must complete. 
    # If any step fails (throws an error), the robot stops, sends you an email, and marks the build with a Red X ‚ùå.
    steps:
      # 1. Download the code from your repo to the GitHub runner
        # uses: This means the robot is using a "pre-made" tool provided by GitHub.
        # checkout@v3: The robot‚Äôs virtual computer starts completely empty. 
        # This command tells the robot: "Go to my repository, copy all the files (scripts, data, etc.), and put them on this virtual computer so I can work on them."
      - uses: actions/checkout@v3

      # 2. Set up a clean Python environment
        # What it does: This installs Python onto the virtual Linux computer.
        # The Parameter (python-version: '3.9'): This is very important for consistency.
        # It ensures the robot uses exactly the same version of Python you used on your laptop. If your code works here, it proves it works on Python 3.9.
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
# 
      # 3. Install only the libraries needed for the test
        # run: This tells the robot to type a command into its terminal.
        # The Logic: Your risk_engine.py script requires pandas and pyarrow to run. 
        # The robot needs to install these into its virtual environment first, just like you did on your own computer using pip install.
      - name: Install dependencies
        run: |
          pip install pandas pyarrow pyspark

      # 4. Run the engine to make sure there are no code errors
      - name: Run Risk Calculations Test
        run: python risk_engine.py


  # --- PHASE 2: CD (Continuous Deployment) ---
    deploy-infrastructure:
      # needs: test-and-validate: This is the most important line in a professional pipeline. 
      # It tells GitHub: "Do not run this deployment if the CI tests (testing and validation) failed."
      needs: test-and-validate # Only deploy if the tests above pass!
      runs-on: ubuntu-latest

      # permissions: This section gives the robot permission to push Docker images to GitHub's Container Registry.
      permissions:
        packages: write
        contents: read
      steps:
        - uses: actions/checkout@v3

        # Logging in to the Warehouse
        - name: Log in to GitHub Container Registry
          # ghcr.io: This is GitHub‚Äôs "Warehouse" for Docker Images.
          # ${{ secrets.GITHUB_TOKEN }}: This is a security feature. It‚Äôs a temporary password GitHub creates automatically so you don't have to put your real password in the code.
          # docker login: This is like the delivery driver showing their ID badge at the warehouse gate to get permission to enter.
          run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
    
        # Building and Shipping the Docker Image
        - name: Build and Push Docker Image (The "Deployment")
            #docker build:
            # The robot reads your Dockerfile.
            # It creates a "frozen" version of your computer environment (with Python, your libraries, and your code).
            # It labels it with your repository name and the tag :latest.
            # docker push:
            # This uploads that frozen package to the internet (GitHub's Registry).
            # Now, anyone in the bank with permission can download this image and run your risk engine exactly how you built it, without needing to install anything.
          run: |
            docker build -t ghcr.io/${{ github.repository }}:latest .
            docker push ghcr.io/${{ github.repository }}:latest
            echo "üöÄ CD Complete: Model Infrastructure deployed to Registry."
